<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asteroid Impact Simulator — 3D Globe</title>

  <!-- Roboto font -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <!-- CesiumJS CSS -->
  <link href="https://unpkg.com/cesium@1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #7c3aed;
      --muted: #94a3b8;
      --glass: rgba(255,255,255,0.03);
      font-family: 'Roboto', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    * {
      box-sizing: border-box;
    }
    html, body, #cesiumContainer {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      height: 100vh;
      display: flex;
      background: linear-gradient(180deg, #071026 0%, #081426 60%);
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
    }
    .app {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    .globe-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transition: transform 0.3s ease-in-out;
    }
    .globe-container.shifted {
      transform: translateX(-210px);
    }
    #cesiumContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    }
    #cesiumContainer .cesium-viewer {
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: 100% !important;
      height: 100% !important;
    }
    #cesiumContainer canvas {
      width: 100% !important;
      height: 100% !important;
      display: block !important;
    }
    .panel {
      position: absolute;
      top: 0;
      right: -420px;
      width: 420px;
      height: 100%;
      background: var(--card);
      box-shadow: -6px 0 20px rgba(2,6,23,0.6);
      transition: right 0.3s ease-in-out;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      z-index: 700;
    }
    .panel.open {
      right: 0;
    }
    .toggle-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: linear-gradient(180deg, var(--accent), #5b21b6);
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(92,33,182,0.18);
      z-index: 800;
    }
    .card {
      background: var(--card);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      flex-shrink: 0;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .label {
      min-width: 88px;
      font-size: 13px;
      color: var(--muted);
      flex-shrink: 0;
      font-weight: 500;
    }
    .value {
      font-weight: 600;
      min-width: 90px;
      text-align: right;
      flex-shrink: 0;
    }
    input[type=range], input[type=text], select {
      width: 100%;
      max-width: 200px;
      padding: 6px;
      border-radius: 6px;
      background: var(--glass);
      color: inherit;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .outputs {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .output {
      background: var(--glass);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
    }
    .output strong {
      width: 180px;
      display: inline-block;
    }
    .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      background: linear-gradient(180deg, var(--accent), #5b21b6);
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(92,33,182,0.18);
      flex: 1;
      min-width: 100px;
    }
    button.secondary {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: none;
      color: var(--muted);
    }
    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .legend .sw {
      width: 18px;
      height: 10px;
      border-radius: 4px;
    }
    .sw.red {
      background: linear-gradient(90deg, rgba(255,69,58,0.95), rgba(255,86,86,0.6));
    }
    .sw.orange {
      background: linear-gradient(90deg, #ff8a00, #ffb86b);
    }
    .sw.yellow {
      background: linear-gradient(90deg, #ffd54a, #fff59d);
    }
    .sw.mild {
      background: linear-gradient(90deg, #c8f7a6, #e6ffcf);
    }
    .sw.blue-severe {
      background: linear-gradient(90deg, #1e40af, #3b82f680);
    }
    .sw.blue-heavy {
      background: linear-gradient(90deg, #3b82f6, #60a5fa80);
    }
    .sw.blue-moderate {
      background: linear-gradient(90deg, #60a5fa, #93c5fd80);
    }
    .sw.blue-mild {
      background: linear-gradient(90deg, #bfdbfe, #dbeafe80);
    }
    @media (max-width: 920px) {
      .panel {
        width: 100%;
        right: -100%;
      }
      .globe-container.shifted {
        transform: translateX(-50%);
      }
      .output strong {
        width: 140px;
      }
      .row {
        gap: 8px;
      }
      .label {
        min-width: 70px;
      }
      .value {
        min-width: 60px;
      }
      input[type=range], input[type=text], select {
        max-width: 100%;
      }
      .buttons {
        justify-content: space-between;
      }
      button {
        flex: none;
        min-width: auto;
        padding: 8px 12px;
        font-size: 14px;
      }
    }
    @media (max-width: 480px) {
      .output strong {
        width: 100%;
        display: block;
        margin-bottom: 4px;
      }
      .output {
        padding: 8px;
        font-size: 12px;
      }
      .legend {
        justify-content: center;
      }
    }
    .tooltip-content {
      font-size: 13px;
    }
    .fall-wrap {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
      overflow: visible;
      z-index: 600;
    }
    .fall {
      position: absolute;
      font-size: 36px;
      transform: translate(-50%, -50%);
      opacity: 0;
    }
    .muted-small {
      font-size: 12px;
      color: var(--muted);
    }
    #loadingOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 1000;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      right: 60px;
      z-index: 500;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="globe-container" id="globeContainer">
      <div id="cesiumContainer" class="fullSize"></div>
      <div class="fall-wrap" id="fallWrap" aria-hidden="true"></div>
      <div id="loadingOverlay">
        <h1>Loading...</h1>
      </div>
      <div id="toolbar"></div>
    </div>
    <button id="togglePanel" class="toggle-btn">☰</button>
    <div class="panel" id="panel">
      <div class="card">
        <h3 style="margin: 0">Asteroid Impact Simulator</h3>
        <div class="controls" id="controls">
          <div class="row">
            <div class="label">Mass (kg)</div>
            <div style="flex:1"><input id="massRange" type="range" min="1e6" max="1e13" step="1" value="1e9"></div>
            <div class="value" id="massVal">1,000,000,000</div>
          </div>
          <div class="row">
            <div class="label">Speed (m/s)</div>
            <div style="flex:1"><input id="speedRange" type="range" min="5000" max="50000" step="100" value="20000"></div>
            <div class="value" id="speedVal">20,000</div>
          </div>
          <div class="row">
            <div class="label">Density (kg/m³)</div>
            <div style="flex:1"><input id="densityRange" type="range" min="1000" max="8000" step="100" value="3000"></div>
            <div class="value" id="densityVal">3,000</div>
          </div>
          <div class="row">
            <div class="label">Impact Angle (°)</div>
            <div style="flex:1"><input id="angleRange" type="range" min="10" max="90" step="1" value="45"></div>
            <div class="value" id="angleVal">45°</div>
          </div>
          <div class="row">
            <div class="label">Deflection Angle (°)</div>
            <div style="flex:1"><input id="deflectAngleRange" type="range" min="0" max="30" step="0.1" value="0"></div>
            <div class="value" id="deflectAngleVal">0.0°</div>
          </div>
          <div class="row">
            <div class="label">Country</div>
            <select id="countrySelect" style="width:100%; padding:6px; border-radius:6px; background:var(--glass); color:inherit; border:1px solid rgba(255,255,255,0.06);">
              <option value="">Select Country</option>
            </select>
          </div>
          <div class="row">
            <div class="label">State/Region</div>
            <select id="stateSelect" style="width:100%; padding:6px; border-radius:6px; background:var(--glass); color:inherit; border:1px solid rgba(255,255,255,0.06);">
              <option value="">Select State</option>
            </select>
          </div>
          <div class="row">
            <div class="label">Latitude</div>
            <div style="flex:1"><input id="latRange" type="range" min="-90" max="90" step="0.0001" value="0"></div>
            <div class="value" id="latVal">0.0000°</div>
          </div>
          <div class="row">
            <div class="label">Longitude</div>
            <div style="flex:1"><input id="lngRange" type="range" min="-180" max="180" step="0.0001" value="0"></div>
            <div class="value" id="lngVal">0.0000°</div>
          </div>
          <div class="row">
            <div class="label">Deflection Method</div>
            <select id="deflectMethod" style="width:100%; padding:6px; border-radius:6px; background:var(--glass); color:inherit; border:1px solid rgba(255,255,255,0.06);">
              <option value="none">No Deflection</option>
              <option value="kinetic">Kinetic Impactor</option>
              <option value="nuclear">Nuclear Deflection</option>
              <option value="gravity">Gravity Tractor</option>
            </select>
          </div>
          <div class="buttons" style="margin-top:6px">
            <button id="simulateBtn">Simulate Impact</button>
            <button id="resetBtn" class="secondary">Reset</button>
            <button id="animateBtn" class="secondary">Animate Fall</button>
          </div>
        </div>
      </div>
      <div class="card">
        <h3 style="margin:6px 0 10px 0">NASA NEO Integration</h3>
        <button id="fetchNeoBtn">Fetch Upcoming NEOs</button>
        <select id="neoSelect" style="width:100%; margin-top:10px; padding:6px; border-radius:6px; background:var(--glass); color:inherit; border:1px solid rgba(255,255,255,0.06);">
          <option value="">Select NEO</option>
        </select>
        <div class="muted-small" style="margin-top:8px">Fetches near-Earth objects from NASA's API. Select one to auto-set mass, speed, and density based on real data (hypothetical impact).</div>
      </div>
      <div class="card outputs">
        <div class="output"><strong>Asteroid diameter:</strong> <span id="astDia">—</span> m</div>
        <div class="output"><strong>Kinetic energy:</strong> <span id="keVal">—</span> J (<span id="keSci">—</span>)</div>
        <div class="output"><strong>Airburst altitude:</strong> <span id="airburstVal">—</span> km</div>
        <div class="output"><strong>Crater diameter:</strong> <span id="craterVal">—</span> km</div>
        <div class="output"><strong>Blast radii (Severe/Heavy/Mod/Mild):</strong> <span id="radiiVal">—</span> km</div>
        <div class="output"><strong>Thermal radiation radius:</strong> <span id="thermalVal">—</span> km</div>
        <div class="output"><strong>Seismic magnitude:</strong> <span id="seismicVal">—</span></div>
        <div class="output"><strong>Deflected:</strong> <span id="deflectedVal">—</span>%</div>
        <div class="output"><strong>Fragmented:</strong> <span id="fragmentedVal">—</span>%</div>
        <div class="output"><strong>Affected population:</strong> <span id="popAffected">—</span></div>
        <div class="output"><strong>Estimated fatalities:</strong> <span id="fatalitiesVal">—</span></div>
        <div class="output" id="warningBox" style="display:none;background:linear-gradient(90deg,#3b0832, #6b1b43);color:#fff">⚠️ <span id="warningText"></span></div>
        <div class="muted-small" id="popNote">Population estimated using country-average density. Click the globe to simulate and fetch local country data.</div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
          <div class="legend">
            <div class="sw red"></div><div style="font-size:13px;color:var(--muted);">Severe (Land)</div>
            <div class="sw orange" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Heavy (Land)</div>
            <div class="sw yellow" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Moderate (Land)</div>
            <div class="sw mild" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Mild (Land)</div>
            <div class="sw blue-severe" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Severe (Sea)</div>
            <div class="sw blue-heavy" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Heavy (Sea)</div>
            <div class="sw blue-moderate" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Moderate (Sea)</div>
            <div class="sw blue-mild" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Mild (Sea)</div>
          </div>
        </div>
      </div>
      <div class="card" style="text-align:center;font-size:13px;color:var(--muted)">
        Tip: drag sliders — simulation updates instantly. Click/rotate/scroll to zoom the globe to explore.
      </div>
    </div>
  </div>

  <!-- CesiumJS with primary and fallback CDN (pinned to stable version) -->
  <script src="https://unpkg.com/cesium@1.120/Build/Cesium/Cesium.js"></script>
  <script>
    // Fallback for CesiumJS if primary CDN fails
    if (typeof Cesium === 'undefined') {
      document.write('<script src="https://cdn.jsdelivr.net/npm/cesium@1.120/Build/Cesium/Cesium.js"><\/script>');
    }
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      if (typeof Cesium === 'undefined') {
        console.error('CesiumJS failed to load. Please check CDN links or network connection.');
        const warnBox = document.getElementById('warningBox');
        const warnText = document.getElementById('warningText');
        warnBox.style.display = 'block';
        warnText.textContent = 'Error: CesiumJS library failed to load. Please refresh the page or check your network.';
        return;
      }

      // --- Toggle Panel ---
      const toggleBtn = document.getElementById('togglePanel');
      const panel = document.getElementById('panel');
      const globeContainer = document.getElementById('globeContainer');
      function togglePanel() {
        if (panel.classList.contains('open')) {
          panel.classList.remove('open');
          globeContainer.classList.remove('shifted');
          toggleBtn.textContent = '☰';
        } else {
          panel.classList.add('open');
          globeContainer.classList.add('shifted');
          toggleBtn.textContent = '×';
        }
      }
      toggleBtn.addEventListener('click', togglePanel);

      // --- CesiumJS Setup ---
      async function initializeViewer() {
        const ionToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJjOTJhOWYwZi1mNzc5LTQ0YzktYjVmMi00MDZiYjQ2ZmE5NmUiLCJpZCI6MzQ3MjcwLCJpYXQiOjE3NTk2MTg0MDd9.5lX_hVUnKo70VaAzshOrf4Zj5nqCNmpuVZ48VEDMAVY';
        Cesium.Ion.defaultAccessToken = ionToken;
        console.log('Using Cesium Ion Token:', ionToken.substring(0, 20) + '...');

        const viewer = new Cesium.Viewer('cesiumContainer', {
          baseLayerPicker: false,
          geocoder: false,
          homeButton: false,
          sceneModePicker: false,
          navigationHelpButton: false,
          animation: false,
          timeline: false,
          fullscreenButton: false,
          vrButton: false,
          infoBox: false,
          selectionIndicator: false,
          sceneMode: Cesium.SceneMode.SCENE3D,
        });

        // Explicitly set canvas size to match container
        const container = viewer.container;
        const canvas = viewer.scene.canvas;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        viewer.resize();
        viewer.scene.requestRender();

        // Hide loading overlay
        const loadingOverlay = document.getElementById('loadingOverlay');
        loadingOverlay.style.display = 'none';

        // Constrain camera to prevent excessive zoom-out and ensure centering
        viewer.scene.screenSpaceCameraController.maximumZoomDistance = 25000000;
        viewer.scene.screenSpaceCameraController.minimumZoomDistance = 1000;
        viewer.scene.screenSpaceCameraController.enableTilt = false;

        // Set initial view to center Earth
        const initialZoomHeight = window.innerWidth <= 920 ? 10000000 : 20000000;
        try {
          viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(0, 0, initialZoomHeight),
            orientation: {
              heading: Cesium.Math.toRadians(0),
              pitch: Cesium.Math.toRadians(-90),
              roll: 0
            }
          });
        } catch (e) {
          console.error('Failed to set initial camera view:', e);
        }

        viewer.scene.globe.enableLighting = true;

        // Load 3D tileset (OSM Buildings, ID )
        try {
          console.log('Attempting to load 3D tileset (ID: 380185)...');
          const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(380185);
          tileset.maximumScreenSpaceError = 16;
          viewer.scene.primitives.add(tileset);
          console.log('3D tileset loaded successfully.');
          viewer.resize();
          viewer.scene.requestRender();
        } catch (e) {
          console.error('Failed to load 3D tileset:', e);
        }

        // Dynamic canvas resize handler
        function syncCanvasSize() {
          const rect = container.getBoundingClientRect();
          if (canvas.width !== rect.width || canvas.height !== rect.height) {
            console.log(`Resizing canvas: ${canvas.width}x${canvas.height} -> ${rect.width}x${rect.height}`);
            canvas.width = rect.width;
            canvas.height = rect.height;
            viewer.resize();
            viewer.scene.requestRender();
          }
          requestAnimationFrame(syncCanvasSize);
        }
        requestAnimationFrame(syncCanvasSize);

        // Handle zoom events to recenter
        viewer.camera.moveEnd.addEventListener(() => {
          const cartographic = viewer.camera.positionCartographic;
          if (cartographic && !isNaN(cartographic.height)) {
            const height = cartographic.height;
            if (height > 20000000) {
              try {
                viewer.camera.setView({
                  destination: Cesium.Cartesian3.fromDegrees(0, 0, Math.min(height, 25000000)),
                  orientation: {
                    heading: Cesium.Math.toRadians(0),
                    pitch: Cesium.Math.toRadians(-90),
                    roll: 0
                  }
                });
              } catch (e) {
                console.warn('Camera recenter failed:', e);
              }
              viewer.scene.requestRender();
            }
          }
        });

        return viewer;
      }

      const viewer = await initializeViewer();
      const impactEntities = [];

      // Resize handler for window changes
      window.addEventListener('resize', () => {
        const container = viewer.container;
        const canvas = viewer.scene.canvas;
        const rect = container.getBoundingClientRect();
        if (canvas.width !== rect.width || canvas.height !== rect.height) {
          console.log(`Window resize: Canvas ${canvas.width}x${canvas.height} -> Container ${rect.width}x${rect.height}`);
          canvas.width = rect.width;
          canvas.height = rect.height;
          viewer.resize();
          viewer.scene.requestRender();
        }
      });

      // --- Utilities ---
      const $ = id => document.getElementById(id);
      const fmt = (v) => Number(v).toLocaleString();
      const fmtFixed = (v, n=2) => Number(v).toLocaleString(undefined, {maximumFractionDigits: n});
      const fmtSci = (v) => {
        if (!isFinite(v)) return '—';
        const abs = Math.abs(v);
        if (abs === 0) return '0';
        if (abs < 1e3 || abs > 1e8) return v.toExponential(3);
        return v.toLocaleString();
      };

      function debounce(fn, wait=120) {
        let t;
        return function(...args) {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), wait);
        };
      }

      // --- DOM Elements ---
      const massR = $('massRange'), massV = $('massVal');
      const speedR = $('speedRange'), speedV = $('speedVal');
      const densityR = $('densityRange'), densityV = $('densityVal');
      const angleR = $('angleRange'), angleV = $('angleVal');
      const deflectAngleR = $('deflectAngleRange'), deflectAngleV = $('deflectAngleVal');
      const countrySel = $('countrySelect');
      const stateSel = $('stateSelect');
      const latR = $('latRange'), latV = $('latVal');
      const lngR = $('lngRange'), lngV = $('lngVal');
      const deflectMethod = $('deflectMethod');
      const astDiaEl = $('astDia'), keValEl = $('keVal'), keSciEl = $('keSci');
      const airburstEl = $('airburstVal'), craterEl = $('craterVal'), radiiEl = $('radiiVal');
      const thermalEl = $('thermalVal'), seismicEl = $('seismicVal');
      const deflectedEl = $('deflectedVal'), fragmentedEl = $('fragmentedVal');
      const popAffectedEl = $('popAffected'), fatalitiesEl = $('fatalitiesVal');
      const warnBox = $('warningBox'), warnText = $('warningText');
      const popNote = $('popNote');

      function updateDisplays() {
        massV.textContent = fmt(Number(massR.value) || 1e9);
        speedV.textContent = fmt(Number(speedR.value) || 20000);
        densityV.textContent = fmt(Number(densityR.value) || 3000);
        angleV.textContent = fmtFixed(Number(angleR.value) || 45, 1) + '°';
        deflectAngleV.textContent = fmtFixed(Number(deflectAngleR.value) || 0, 1) + '°';
        latV.textContent = Number(latR.value || 0).toFixed(4) + '°';
        lngV.textContent = Number(lngR.value || 0).toFixed(4) + '°';
      }
      [massR, speedR, densityR, angleR, deflectAngleR, latR, lngR].forEach(el => el.addEventListener('input', updateDisplays));
      updateDisplays();

      // --- Country and State Selection ---
      async function fetchCountries() {
        try {
          const res = await fetch('https://restcountries.com/v3.1/all?fields=name,cca2,latlng');
          if (!res.ok) throw new Error('Country fetch failed');
          const data = await res.json();
          const countries = data.sort((a, b) => a.name.common.localeCompare(b.name.common));
          countrySel.innerHTML = '<option value="">Select Country</option>';
          countries.forEach(country => {
            const opt = document.createElement('option');
            opt.value = JSON.stringify({ code: country.cca2, latlng: country.latlng });
            opt.textContent = country.name.common;
            countrySel.appendChild(opt);
          });
        } catch (e) {
          console.error('Country fetch error:', e);
          countrySel.innerHTML = '<option value="">Error fetching countries</option>';
        }
      }

      async function fetchStates(countryCode) {
        try {
          const res = await fetch(`https://api.geonames.org/children?geonameId=${countryCode}&username=demo&style=full`);
          if (!res.ok) throw new Error('State fetch failed');
          const data = await res.json();
          stateSel.innerHTML = '<option value="">Select State</option>';
          if (data.geonames && data.geonames.length > 0) {
            data.geonames.forEach(state => {
              const opt = document.createElement('option');
              opt.value = JSON.stringify({ lat: state.lat, lng: state.lng });
              opt.textContent = state.name;
              stateSel.appendChild(opt);
            });
          } else {
            stateSel.innerHTML = '<option value="">No states available</option>';
          }
        } catch (e) {
          console.error('State fetch error:', e);
          stateSel.innerHTML = '<option value="">Error fetching states</option>';
        }
      }

      countrySel.addEventListener('change', async (e) => {
        if (!e.target.value) {
          stateSel.innerHTML = '<option value="">Select State</option>';
          return;
        }
        const { code, latlng } = JSON.parse(e.target.value);
        latR.value = latlng[0];
        lngR.value = latlng[1];
        updateDisplays();
        await fetchStates(code);
        debouncedSimulate(false);
      });

      stateSel.addEventListener('change', (e) => {
        if (!e.target.value) return;
        const { lat, lng } = JSON.parse(e.target.value);
        latR.value = lat;
        lngR.value = lng;
        updateDisplays();
        debouncedSimulate(false);
      });

      fetchCountries();

      // --- Physics ---
      function computeAsteroidDiameter(massKg, density) {
        density = Number(density) || 1000;
        const vol = massKg / density;
        const radius = Math.cbrt((3 * vol) / (4 * Math.PI));
        return isFinite(radius) ? 2 * radius : 0;
      }

      function computeKE(massKg, speedMs, angleDeg, deflectAngleDeg) {
        const effectiveSpeed = speedMs * Math.cos(Cesium.Math.toRadians(deflectAngleDeg));
        return 0.5 * massKg * effectiveSpeed * effectiveSpeed;
      }

      function estimateCraterDiameterKm(keJ, angleDeg) {
        const angleFactor = Math.sin(Cesium.Math.toRadians(angleDeg));
        const effectiveKE = keJ * angleFactor;
        const C = 0.2;
        const D_m = C * Math.pow(effectiveKE, 0.25);
        return isFinite(D_m) ? D_m / 1000 : 0;
      }

      function estimateAirburstAltitude(diameter_m, speedMs, density, angleDeg) {
        const baseAltitude = 50;
        const sizeFactor = Math.min(25 / diameter_m, 2);
        const speedFactor = Math.min(12000 / speedMs, 1.5);
        const angleFactor = angleDeg / 90;
        const densityFactor = Math.min(2000 / density, 1.5);
        const altitude = baseAltitude * (0.5 * sizeFactor + 0.3 * speedFactor + 0.1 * angleFactor + 0.1 * densityFactor);
        return Math.min(Math.max(altitude, 10), 100);
      }

      function estimateThermalRadiusKm(keJ, angleDeg) {
        const angleFactor = Math.sin(Cesium.Math.toRadians(angleDeg));
        const C_thermal = 0.05;
        const R_m = C_thermal * Math.pow(keJ * angleFactor, 1/3);
        return isFinite(R_m) ? R_m / 1000 : 0;
      }

      function estimateSeismicMagnitude(keJ, angleDeg) {
        const angleFactor = Math.sin(Cesium.Math.toRadians(angleDeg));
        const logE = Math.log10(keJ * angleFactor);
        const M = (logE - 4.8) / 1.5;
        return Math.max(0, Math.min(M, 12));
      }

      function checkAtmosphericDisintegration(diameter_m, speedMs, density, angleDeg) {
        return (
          diameter_m < 25 &&
          (angleDeg > 60 || speedMs < 12000 || density < 2000)
        );
      }

      function computeImpact(massKg, speedMs, density, angleDeg, deflectAngleDeg, deflectPct, fragPct) {
        const effectiveSpeed = speedMs * (1 - deflectPct / 100) * Math.cos(Cesium.Math.toRadians(deflectAngleDeg));
        const effectiveMass = massKg * (1 - fragPct / 100);
        const diameter_m = computeAsteroidDiameter(effectiveMass, density);
        const ke = computeKE(effectiveMass, speedMs, angleDeg, deflectAngleDeg);
        const disintegrates = checkAtmosphericDisintegration(diameter_m, effectiveSpeed, density, angleDeg);

        if (disintegrates) {
          const airburst_km = estimateAirburstAltitude(diameter_m, effectiveSpeed, density, angleDeg);
          return {
            diameter_m, ke, airburst_km, crater_km: 0, severe_km: 0, heavy_km: 0,
            moderate_km: 0, mild_km: 0, thermal_km: 0, seismic_mag: 0, disintegrates: true
          };
        }

        const crater_km = estimateCraterDiameterKm(ke, angleDeg);
        const severe_km = Math.max(0.5, crater_km * 0.6);
        const heavy_km = Math.max(severe_km * 1.8, crater_km * 2.0);
        const moderate_km = Math.max(heavy_km * 1.9, crater_km * 5.0);
        const mild_km = Math.max(moderate_km * 2.2, crater_km * 12.0);
        const thermal_km = estimateThermalRadiusKm(ke, angleDeg);
        const seismic_mag = estimateSeismicMagnitude(ke, angleDeg);

        return {
          diameter_m, ke, airburst_km: 0, crater_km, severe_km, heavy_km,
          moderate_km, mild_km, thermal_km, seismic_mag, disintegrates: false
        };
      }

      // --- Population Estimation ---
      async function reverseGeocodeCountry(lat, lng) {
        try {
          const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&zoom=3&addressdetails=1`;
          const res = await fetch(url, {
            headers: {
              'Accept': 'application/json',
              'User-Agent': 'AsteroidImpactSimulator/1.0'
            }
          });
          if (!res.ok) throw new Error('reverse geocode failed');
          const data = await res.json();
          const countryCode = data && data.address && data.address.country_code ? data.address.country_code.toUpperCase() : null;
          const isSea = !countryCode;
          return { countryCode, isSea };
        } catch (e) {
          console.warn('reverse geocode error', e);
          return { countryCode: null, isSea: false };
        }
      }

      async function fetchCountryDensity(alpha2) {
        try {
          const url = `https://restcountries.com/v3.1/alpha/${alpha2}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error('country fetch failed');
          const data = await res.json();
          const info = Array.isArray(data) ? data[0] : data;
          if (!info || !info.population || !info.area) return null;
          const density = info.population / info.area;
          return { density, population: info.population, area: info.area, name: info.name && info.name.common };
        } catch (e) {
          console.warn('country fetch error', e);
          return null;
        }
      }

      function ringAreas(severe_km, heavy_km, moderate_km, mild_km) {
        const area = (r) => Math.PI * r * r;
        const A_severe = area(severe_km);
        const A_heavy = Math.max(0, area(heavy_km) - A_severe);
        const A_moderate = Math.max(0, area(moderate_km) - area(heavy_km));
        const A_mild = Math.max(0, area(mild_km) - area(moderate_km));
        return { A_severe, A_heavy, A_moderate, A_mild };
      }

      async function estimatePopulationImpact(lat, lng, result) {
        if (result.disintegrates) {
          return { densityData: null, density: 0, perZone: {}, totalAffected: 0, totalFatal: 0, isSea: false };
        }
        const { countryCode, isSea } = await reverseGeocodeCountry(lat, lng);
        if (isSea) {
          return { densityData: null, density: 0, perZone: {}, totalAffected: 0, totalFatal: 0, isSea: true };
        }
        const fallbackDensity = 60;
        let densityData = null;
        if (countryCode) {
          densityData = await fetchCountryDensity(countryCode).catch(() => null);
        }
        const density = densityData && densityData.density ? densityData.density : fallbackDensity;
        const areas = ringAreas(result.severe_km, result.heavy_km, result.moderate_km, result.mild_km);
        const pop_severe = areas.A_severe * density;
        const pop_heavy = areas.A_heavy * density;
        const pop_moderate = areas.A_moderate * density;
        const pop_mild = areas.A_mild * density;
        const totalAffected = pop_severe + pop_heavy + pop_moderate + pop_mild;
        const fatal_severe = pop_severe * 0.9;
        const fatal_heavy = pop_heavy * 0.5;
        const fatal_moderate = pop_moderate * 0.15;
        const fatal_mild = pop_mild * 0.02;
        const totalFatal = fatal_severe + fatal_heavy + fatal_moderate + fatal_mild;
        return {
          densityData,
          density,
          perZone: {
            severe: { area_km2: areas.A_severe, pop: pop_severe, fatal: fatal_severe },
            heavy: { area_km2: areas.A_heavy, pop: pop_heavy, fatal: fatal_heavy },
            moderate: { area_km2: areas.A_moderate, pop: pop_moderate, fatal: fatal_moderate },
            mild: { area_km2: areas.A_mild, pop: pop_mild, fatal: fatal_mild }
          },
          totalAffected,
          totalFatal,
          isSea
        };
      }

      // --- Interaction: Draw on Globe ---
      function clearImpact() {
        impactEntities.forEach(entity => viewer.entities.remove(entity));
        impactEntities.length = 0;
        warnBox.style.display = 'none';
        astDiaEl.textContent = '—';
        keValEl.textContent = '—';
        keSciEl.textContent = '—';
        airburstEl.textContent = '—';
        craterEl.textContent = '—';
        radiiEl.textContent = '—';
        thermalEl.textContent = '—';
        seismicEl.textContent = '—';
        deflectedEl.textContent = '—';
        fragmentedEl.textContent = '—';
        popAffectedEl.textContent = '—';
        fatalitiesEl.textContent = '—';
        popNote.textContent = 'Population estimated using country-average density. Click the globe to simulate and fetch local country data.';
        viewer.scene.requestRender();
      }

      function createEllipse(lng, lat, radius_km, label, isSea, height = 0) {
        if (!isFinite(lng) || !isFinite(lat) || !isFinite(height) || radius_km <= 0) {
          console.warn('Skipping ellipse creation due to invalid coordinates:', { lng, lat, height, radius_km });
          return null;
        }
        const radius_m = radius_km * 1000;
        const colors = isSea
          ? { severe: '#1e40af', heavy: '#3b82f6', moderate: '#60a5fa', mild: '#bfdbfe' }
          : { severe: '#ff4444', heavy: '#ff8a1f', moderate: '#ffd54a', mild: '#c8f7a6' };
        const opacities = { severe: 0.35, heavy: 0.25, moderate: 0.18, mild: 0.12 };
        const color = colors[label.toLowerCase()];
        const opacity = opacities[label.toLowerCase()];
        try {
          const entity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lng, lat, height),
            ellipse: {
              semiMajorAxis: radius_m,
              semiMinorAxis: radius_m,
              material: Cesium.Color.fromCssColorString(color).withAlpha(opacity),
              outline: false
            },
            label: {
              text: `${label}: ${fmtFixed(radius_km, 2)} km`,
              font: '13px Roboto, sans-serif',
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              pixelOffset: new Cesium.Cartesian2(0, -20),
              show: false
            }
          });
          return entity;
        } catch (e) {
          console.error('Failed to create ellipse:', e);
          return null;
        }
      }

      async function drawImpact(lat, lng, result) {
        if (!isFinite(lat) || !isFinite(lng)) {
          console.warn('Skipping drawImpact due to invalid lat/lng:', lat, lng);
          return;
        }
        clearImpact();
        const popEst = await estimatePopulationImpact(lat, lng, result);
        const isSea = popEst.isSea;

        if (result.disintegrates) {
          warnBox.style.display = 'block';
          warnText.textContent = `Meteor disintegrates in atmosphere at ~${fmtFixed(result.airburst_km, 1)} km altitude — no ground impact.`;
          astDiaEl.textContent = fmtFixed(result.diameter_m, 1);
          keValEl.textContent = fmt(parseFloat(result.ke.toFixed(0)));
          keSciEl.textContent = fmtSci(result.ke);
          airburstEl.textContent = fmtFixed(result.airburst_km, 1);
          craterEl.textContent = '0';
          radiiEl.textContent = '0 / 0 / 0 / 0';
          thermalEl.textContent = '0';
          seismicEl.textContent = '0';
          popAffectedEl.textContent = '0';
          fatalitiesEl.textContent = '0';
          popNote.textContent = 'No population affected due to atmospheric disintegration.';
          viewer.scene.requestRender();
          return;
        }

        try {
          const height = 1000;
          const marker = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lng, lat, height),
            point: {
              pixelSize: 10,
              color: Cesium.Color.RED,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 2
            }
          });
          impactEntities.push(marker);
        } catch (e) {
          console.warn('Failed to add marker:', e);
        }

        const mildEllipse = createEllipse(lng, lat, result.mild_km, 'Mild', isSea);
        const moderateEllipse = createEllipse(lng, lat, result.moderate_km, 'Moderate', isSea);
        const heavyEllipse = createEllipse(lng, lat, result.heavy_km, 'Heavy', isSea);
        const severeEllipse = createEllipse(lng, lat, result.severe_km, 'Severe', isSea);
        if (mildEllipse) impactEntities.push(mildEllipse);
        if (moderateEllipse) impactEntities.push(moderateEllipse);
        if (heavyEllipse) impactEntities.push(heavyEllipse);
        if (severeEllipse) impactEntities.push(severeEllipse);

        try {
          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(lng, lat, 10000),
            orientation: {
              heading: Cesium.Math.toRadians(0),
              pitch: Cesium.Math.toRadians(-45),
              roll: 0
            },
            duration: 1,
            complete: () => {
              viewer.scene.requestRender();
            }
          });
        } catch (e) {
          console.warn('Camera flyTo failed:', e);
        }

        astDiaEl.textContent = fmtFixed(result.diameter_m, 1);
        keValEl.textContent = fmt(parseFloat(result.ke.toFixed(0)));
        keSciEl.textContent = fmtSci(result.ke);
        airburstEl.textContent = '0';
        craterEl.textContent = fmtFixed(result.crater_km, 2);
        radiiEl.textContent = `${fmtFixed(result.severe_km, 2)} / ${fmtFixed(result.heavy_km, 2)} / ${fmtFixed(result.moderate_km, 2)} / ${fmtFixed(result.mild_km, 2)}`;
        thermalEl.textContent = fmtFixed(result.thermal_km, 2);
        seismicEl.textContent = fmtFixed(result.seismic_mag, 1);

        popNote.textContent = isSea
          ? 'Impact over sea — no population affected.'
          : 'Estimating population — fetching country data...';
        try {
          if (!isSea) {
            const totalAff = Math.round(popEst.totalAffected);
            const totalFatal = Math.round(popEst.totalFatal);
            popAffectedEl.textContent = totalAff.toLocaleString();
            fatalitiesEl.textContent = totalFatal.toLocaleString();
            if (totalAff < 1) popAffectedEl.textContent = '<1';
            if (totalFatal < 1) fatalitiesEl.textContent = '<1';
            if (popEst.densityData && popEst.densityData.name) {
              popNote.textContent = `Using country-average density for ${popEst.densityData.name} (${Math.round(popEst.densityData.density)} ppl/km²). This is a coarse estimate.`;
            } else {
              popNote.textContent = `Using fallback global-average density (${Math.round(popEst.density)} ppl/km²). For more accuracy, connect a gridded population dataset.`;
            }
          } else {
            popAffectedEl.textContent = '0';
            fatalitiesEl.textContent = '0';
          }
        } catch (e) {
          popNote.textContent = 'Population estimation failed — showing no estimate.';
          popAffectedEl.textContent = '—';
          fatalitiesEl.textContent = '—';
          console.warn('Population estimation error:', e);
        }
        viewer.scene.requestRender();
      }

      // --- Raycasting for Clicking Globe ---
      const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
      handler.setInputAction((click) => {
        const cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
        if (cartesian) {
          const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
          if (cartographic && !isNaN(Cesium.Math.toDegrees(cartographic.longitude)) && !isNaN(Cesium.Math.toDegrees(cartographic.latitude))) {
            const lng = Cesium.Math.toDegrees(cartographic.longitude);
            const lat = Cesium.Math.toDegrees(cartographic.latitude);
            latR.value = Math.max(-90, Math.min(90, lat));
            lngR.value = Math.max(-180, Math.min(180, lng));
            updateDisplays();
            // Reset country and state selections
            countrySel.value = '';
            stateSel.innerHTML = '<option value="">Select State</option>';
            simulate(true);
          } else {
            console.warn('Invalid cartographic from click');
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      // --- Tooltip Handling ---
      let tooltipDiv = null;
      function showTooltip(event, content) {
        if (!tooltipDiv) {
          tooltipDiv = document.createElement('div');
          tooltipDiv.style.position = 'absolute';
          tooltipDiv.style.background = 'rgba(0,0,0,0.8)';
          tooltipDiv.style.color = '#fff';
          tooltipDiv.style.padding = '5px 10px';
          tooltipDiv.style.borderRadius = '5px';
          tooltipDiv.style.pointerEvents = 'none';
          tooltipDiv.style.zIndex = '1000';
          document.body.appendChild(tooltipDiv);
        }
        tooltipDiv.innerHTML = content;
        tooltipDiv.style.left = `${event.position.x + 10}px`;
        tooltipDiv.style.top = `${event.position.y + 10}px`;
        tooltipDiv.style.display = 'block';
      }

      function hideTooltip() {
        if (tooltipDiv) {
          tooltipDiv.style.display = 'none';
        }
      }

      handler.setInputAction((movement) => {
        const picked = viewer.scene.pick(movement.endPosition);
        if (picked && picked.id && picked.id.label) {
          showTooltip(movement, picked.id.label.text);
        } else {
          hideTooltip();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      // --- Animation: Falling Emoji ---
      const fallWrap = $('fallWrap');
      function animateFallTo(lat, lng, done) {
        if (!isFinite(lat) || !isFinite(lng)) {
          console.warn('Skipping fall animation due to invalid lat/lng');
          done && done();
          return;
        }
        const screenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(
          viewer.scene,
          Cesium.Cartesian3.fromDegrees(lng, lat)
        );
        if (!screenPos) {
          console.warn('Failed to get screen position for fall animation');
          done && done();
          return;
        }

        const el = document.createElement('div');
        el.className = 'fall';
        el.innerHTML = '☄️';
        el.style.left = `${screenPos.x}px`;
        el.style.top = '-120px';
        el.style.opacity = '1';
        el.style.transition = 'top 900ms cubic-bezier(.2,.9,.2,1), opacity 200ms linear';
        fallWrap.appendChild(el);

        void el.offsetWidth;
        const clampY = Math.min(Math.max(screenPos.y, 20), fallWrap.clientHeight - 20);
        el.style.top = `${clampY}px`;

        const onEnd = (ev) => {
          if (ev.propertyName === 'top') {
            el.removeEventListener('transitionend', onEnd);
            el.style.transition = 'opacity 300ms linear';
            el.style.opacity = '0';
            setTimeout(() => {
              el.remove();
              done && done();
            }, 320);
          }
        };
        el.addEventListener('transitionend', onEnd);

        setTimeout(() => {
          if (document.body.contains(el)) {
            el.remove();
            done && done();
          }
        }, 1600);
      }

      // --- Simulation ---
      const debouncedSimulate = debounce((animate = false) => simulate(animate), 80);

      function simulate(animate = false) {
        try {
          let mass = Number(massR.value);
          let speed = Number(speedR.value);
          let density = Number(densityR.value);
          let angle = Number(angleR.value);
          let deflectAngle = Number(deflectAngleR.value);
          let lat = Number(latR.value);
          let lng = Number(lngR.value);

          // Input validation and defaults
          mass = isFinite(mass) ? mass : 1e9;
          speed = isFinite(speed) ? speed : 20000;
          density = isFinite(density) && density > 0 ? density : 3000;
          angle = isFinite(angle) ? Math.max(10, Math.min(90, angle)) : 45;
          deflectAngle = isFinite(deflectAngle) ? Math.max(0, Math.min(30, deflectAngle)) : 0;
          lat = isFinite(lat) ? Math.max(-90, Math.min(90, lat)) : 0;
          lng = isFinite(lng) ? Math.max(-180, Math.min(180, lng)) : 0;

          let deflectPct = 0;
          let fragPct = 0;
          const method = deflectMethod.value;
          if (method === 'kinetic') {
            deflectPct = 10;
            fragPct = 5;
          } else if (method === 'nuclear') {
            deflectPct = 20;
            fragPct = 30;
          } else if (method === 'gravity') {
            deflectPct = 5;
            fragPct = 0;
          }

          console.log('Simulation inputs:', { mass, speed, density, angle, deflectAngle, lat, lng });

          const res = computeImpact(mass, speed, density, angle, deflectAngle, deflectPct, fragPct);

          astDiaEl.textContent = fmtFixed(res.diameter_m, 1);
          keValEl.textContent = fmt(parseFloat(res.ke.toFixed(0)));
          keSciEl.textContent = fmtSci(res.ke);
          airburstEl.textContent = res.disintegrates ? fmtFixed(res.airburst_km, 1) : '0';
          craterEl.textContent = res.disintegrates ? '0' : fmtFixed(res.crater_km, 2);
          radiiEl.textContent = res.disintegrates ? '0 / 0 / 0 / 0' : `${fmtFixed(res.severe_km, 2)} / ${fmtFixed(res.heavy_km, 2)} / ${fmtFixed(res.moderate_km, 2)} / ${fmtFixed(res.mild_km, 2)}`;
          thermalEl.textContent = res.disintegrates ? '0' : fmtFixed(res.thermal_km, 2);
          seismicEl.textContent = res.disintegrates ? '0' : fmtFixed(res.seismic_mag, 1);
          deflectedEl.textContent = deflectPct;
          fragmentedEl.textContent = fragPct;

          const megatons = res.ke / 4.184e15;
          if (res.disintegrates) {
            warnBox.style.display = 'block';
            warnText.textContent = `Meteor disintegrates in atmosphere at ~${fmtFixed(res.airburst_km, 1)} km altitude — no ground impact.`;
          } else if (megatons > 1000) {
            warnText.textContent = `Extreme energy: ~${Math.round(megatons).toLocaleString()} megatons — global catastrophic potential.`;
            warnBox.style.display = 'block';
          } else if (megatons > 10) {
            warnText.textContent = `Large impact: ~${Math.round(megatons).toLocaleString()} megatons — regional devastation.`;
            warnBox.style.display = 'block';
          } else {
            warnBox.style.display = 'none';
          }

          if (animate) {
            console.log('Starting fall animation');
            animateFallTo(lat, lng, () => drawImpact(lat, lng, res));
          } else {
            drawImpact(lat, lng, res);
          }
        } catch (e) {
          console.error('Simulation error:', e);
          warnBox.style.display = 'block';
          warnText.textContent = 'Error during simulation — please check input values.';
        }
      }

      // --- NASA NEO API Integration ---
      const apiKey = '4gkxMlrvfAdWiMnr4vCVL7zwizhtX77QCPALiQrd';

      async function fetchNEOs() {
        const today = new Date().toISOString().split('T')[0];
        const url = `https://api.nasa.gov/neo/rest/v1/feed?start_date=${today}&api_key=${apiKey}`;
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error('NEO API fetch failed');
          const data = await res.json();
          const neos = [];
          for (let date in data.near_earth_objects) {
            data.near_earth_objects[date].forEach(neo => {
              if (neo.estimated_diameter && neo.close_approach_data && neo.close_approach_data[0]) {
                neos.push(neo);
              }
            });
          }
          const sel = $('neoSelect');
          sel.innerHTML = '<option value="">Select NEO</option>';
          neos.forEach(neo => {
            const opt = document.createElement('option');
            opt.value = JSON.stringify({
              name: neo.name,
              dia_min: neo.estimated_diameter.meters.estimated_diameter_min,
              dia_max: neo.estimated_diameter.meters.estimated_diameter_max,
              vel: neo.close_approach_data[0].relative_velocity.kilometers_per_second,
              density: 3000
            });
            opt.textContent = `${neo.name} (Close Approach: ${neo.close_approach_data[0].close_approach_date})`;
            sel.appendChild(opt);
          });
          if (neos.length === 0) {
            sel.innerHTML += '<option value="">No NEOs found in the next week</option>';
          }
        } catch (e) {
          console.error('NEO fetch error:', e);
          $('neoSelect').innerHTML = '<option value="">Error fetching NEOs</option>';
        }
      }

      // --- Events ---
      $('simulateBtn').addEventListener('click', () => simulate(false));
      $('resetBtn').addEventListener('click', () => clearImpact());
      $('animateBtn').addEventListener('click', () => simulate(true));
      [massR, speedR, densityR, angleR, deflectAngleR, latR, lngR].forEach(el => el.addEventListener('input', () => debouncedSimulate(false)));
      deflectMethod.addEventListener('change', () => debouncedSimulate(false));
      simulate(false);

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') simulate(false);
        if (e.key === 'r') clearImpact();
      });

      $('fetchNeoBtn').addEventListener('click', fetchNEOs);
      $('neoSelect').addEventListener('change', (e) => {
        if (!e.target.value) return;
        const d = JSON.parse(e.target.value);
        const avg_dia = (d.dia_min + d.dia_max) / 2;
        const radius = avg_dia / 2;
        const volume = (4 / 3) * Math.PI * Math.pow(radius, 3);
        const mass = d.density * volume;
        const clamped_mass = Math.min(Math.max(mass, 1e6), 1e13);
        setRangeValue(massR, clamped_mass);
        const speed = d.vel * 1000;
        const clamped_speed = Math.min(Math.max(speed, 5000), 50000);
        setRangeValue(speedR, clamped_speed);
        setRangeValue(densityR, d.density);
        simulate(false);
      });

      function setRangeValue(range, v) {
        range.value = v;
        updateDisplays();
        debouncedSimulate(false);
      }
    });
  </script>
</body>
</html>
